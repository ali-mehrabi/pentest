#include <stdio.h>
#include <pcap.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <inttypes.h>

typedef uint32_t tcp_seq; // Define tcp_seq if not available in your system headers

struct sniff_ip {
    uint8_t  ip_vhl;               // version << 4 | header length >> 2
    uint8_t  ip_tos;               // type of service
    uint16_t ip_len;               // total length
    uint16_t ip_id;                // identification
    uint16_t ip_off;               // fragment offset field
#define IP_RF 0x8000              // reserved fragment flag
#define IP_DF 0x4000              // don't fragment flag
#define IP_MF 0x2000              // more fragments flag
#define IP_OFFMASK 0x1fff         // mask for fragmenting bits
    uint8_t  ip_ttl;               // time to live
    uint8_t  ip_p;                 // protocol
    uint16_t ip_sum;               // checksum
    struct  in_addr ip_src, ip_dst; // source and dest address
};

struct sniff_tcp {
    uint16_t th_sport;              // source port
    uint16_t th_dport;              // destination port
    tcp_seq th_seq;                 // sequence number
    tcp_seq th_ack;                 // acknowledgement number
    uint8_t  th_offx2;              // data offset, rsvd
#define TH_OFF(th) (((th)->th_offx2 & 0xf0) >> 4)
    uint8_t  th_flags;
    uint16_t th_win;                // window
    uint16_t th_sum;                // checksum
    uint16_t th_urp;                // urgent pointer
};

#define TH_SYN 0x02
#define TH_ACK 0x10
#define PORT "wlp1s0"

void packet_handler(unsigned char *user_data, const struct pcap_pkthdr *pkthdr, const unsigned char *packet) {
    struct sniff_ip *iph = (struct sniff_ip *)(packet + 14); // Assuming Ethernet frame header is 14 bytes
    struct sniff_tcp *tcph = (struct sniff_tcp *)(packet + 14 + (iph->ip_vhl & 0x0F) * 4);

    // Check if it's a TCP packet with the SYN flag set
    if (iph->ip_p == IPPROTO_TCP && (tcph->th_flags & TH_SYN)) {
        // Print source IP address
        printf("Source IP: %s\n", inet_ntoa(iph->ip_src));

        // Print the SYN packet data
        printf("SYN Packet Data:\n");
        for (int i = 0; i < pkthdr->len; i++) {
            printf("%02x ", packet[i]);
            if ((i + 1) % 16 == 0)
                printf("\n");
        }
        printf("\n\n");

        // Check if it's a SYN-ACK packet
        if (tcph->th_flags & TH_ACK) {
            // Print the SYN-ACK packet data
            printf("SYN-ACK Packet Data:\n");
            for (int i = 0; i < pkthdr->len; i++) {
                printf("%02x ", packet[i]);
                if ((i + 1) % 16 == 0)
                    printf("\n");
            }
            printf("\n\n");
        }

        // Check if it's an ACK packet
        if (tcph->th_flags & TH_ACK) {
            // Print the ACK packet data
            printf("ACK Packet Data:\n");
            for (int i = 0; i < pkthdr->len; i++) {
                printf("%02x ", packet[i]);
                if ((i + 1) % 16 == 0)
                    printf("\n");
            }
            printf("\n\n");
        }
    }
}

int main() {
    pcap_t *handle;
    char errbuf[PCAP_ERRBUF_SIZE];

    // Open the network device for packet capture
    handle = pcap_open_live(PORT, BUFSIZ, 1, 1000, errbuf); // Change "eth0" or to your network interface

    if (handle == NULL) {
        fprintf(stderr, "Couldn't open device: %s\n", errbuf);
        return 2;
    }

    // Set a packet filter to capture only TCP packets
    struct bpf_program fp;
    char filter_exp[] = "tcp";
    if (pcap_compile(handle, &fp, filter_exp, 0, PCAP_NETMASK_UNKNOWN) == -1) {
        fprintf(stderr, "Couldn't parse filter %s: %s\n", filter_exp, pcap_geterr(handle));
        return 2;
    }

    if (pcap_setfilter(handle, &fp) == -1) {
        fprintf(stderr, "Couldn't install filter %s: %s\n", filter_exp, pcap_geterr(handle));
        return 2;
    }

    // Start capturing packets and call packet_handler for each captured packet
    pcap_loop(handle, 0, packet_handler, NULL);

    // Close the capture handle
    pcap_close(handle);

    return 0;
}
